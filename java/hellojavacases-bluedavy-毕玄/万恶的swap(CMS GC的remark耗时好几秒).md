
# 万恶的swap(CMS GC的remark耗时好几秒-慢比挂可怕多了)

可能有点标题党了，毕竟在某些场景下swap还是有点用的，不过还是写写吧，
尽管有`各种实践经验都告诉我们最好是关闭swap`，但通常的事实是`大部分机器都是开着swap的`，因此总是`容易踩到swap的坑`。

【现象】前几天碰到的一个问题，`线上一个核心应用出现了较频繁的CMS GC`，当时分析看到是和应用本身有些关系，
但应用改代码，发布需要几天的时间，因此当时给的`建议是临时将heap size先从4G调整到5G`。

悲催的是运行了几天后，`突然有几台机器开始报警，上机器看到的现象是CMS GC的remark竟然花了20s+`，而实际上这个时候`old也就用了2g+`，这个时间太夸张了，
在之前的case里有写过，`通常remark慢是由于在concurrent-mark结束后到remark开始前的这段时间内，新生代有大量的对象分配`，
但这个应用没这类状况，从`top`上看到的状况是`swap差不多用了一半的空间`，`猜想有可能是因为用到了swap去了造成的`，
`对比了一下之前一些没调整heap size的机器，显示的状况是那些没调的swap的使用基本稳定在0`。

`free -m`显示其实`这个时候内存还是基本够用的`，cached和buffered的大概还有1G多的空间，就是尽管要用到swap，也不应该用那么多，
`Linux在内存不是那么够用的情况下，决定到底是回收cached/buffered占据的内存还是swap，主要取决于/proc/sys/vm/swappiness这个参数`，
这个的默认值是60，值越高表示越倾向于使用swap。

这个应用所使用的虚拟机为7.5G的内存，当heap size调整到5G后，启动的java进程差不多要占到6G左右的空间，这个时候剩下的内存已经只剩1.5G了，
而os本身cached/buffered也用掉了1G多，所以这个时候在内存不够的情况下确实会更加偏向使用swap，而不是去回收cached/buffered占据的内存。

这其实也是一个比较典型的`最后一根稻草`的现象，通常来说，
对于`在线业务`而言，就算不关闭swap，最起码也得`把上面的参数调整下，尽可能的让其倾向于回收cached/buffered占据的内存`，
毕竟`只要一开始用文件来做swap，应用的性能那可就刷刷地下降`了，
`对于在线业务而言，通常由于是集群化的，所以挂并不可怕，但慢就非常可怕了。`

因此通常建议将swappiness这个值调整为0，更保险的方式就是直接`swapoff -a关闭swap`，尽管会有一定的风险，因为内存不够用了机器就直接挂了，
但还是那个观点，`**慢比挂可怕多了**`。

之前发的两起cases的信息发了后，有其中一个case的同学发消息给我，说是他造成的，**其实说实话，我觉得造成故障一点都不可怕**
（08、09年我做HSF的时候`造成过不下4次的严重故障，至少有两次是交易跌0`，不堪回首呀），
甚至我们以前开玩笑说，都应该**给新员工一个造成严重故障的机会和体验，体验紧急故障处理对程序员来说我觉得还是有挺大的帮助的**，
当然，**尽可能地避免造成故障是程序员的本职**。


2013年8月13日



原文：[万恶的swap - 毕玄-林昊](http://hellojava.info/?p=172)

