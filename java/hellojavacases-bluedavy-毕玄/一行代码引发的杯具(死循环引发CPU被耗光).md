
# 一行代码引发的杯具(死循环引发CPU被耗光)

近期碰到一个case，查到最终的原因的时候感觉到些许的无语，`仅仅因为一行代码，差点引发了一个超级严重的故障`
（事实上**要不是`响应速度`以及`容灾`做的还不错，肯定是`严重故障`**了），来回顾下这个Case。

【现象】`有个应用突然报警，一个机房的所有机器健康检查全部失败，vip挂掉，但其他机房的机器一切正常`，这太诡异了，于是开始排查。

健康检查全部失败，看了下`日志，发现http返回的又是499`，因此`说明还是后端慢或处理不过来`，还好的是这个时候做线程dump还有用，
`dump了下线程后显示所有的http处理线程都在处理`，但悲催的是看起来这些线程不像有问题的…

于是继续瞎看，看`cpu消耗，发现竟然还有一个cpu会被耗光`，猜想那估计是`线程里有什么地方死循环或无限递归`了，
于是`top -H找到相应的线程id，结合线程dump看到了耗光cpu的线程`，其`堆栈显示该线程正在做的动作为遍历exception`，类似如下：
```java
    while (exception.getCause() != null) {
        // do sth…
    }
```
从这说来，就是 `exception.getCause() 一直都不为 null`。

这个时候最需要知道的是这个Exception到底是什么…

因为是一直在执行的，因此想到`查看这个exception到底是什么的方法是dump内存`，然后看看到底是什么，
于是`dump内存，用MAT打开分析，找到对应的线程`，果然很顺利的`找到了一个业务自定义的Exception instance`，
点开一看，看到的是`这个exception instance的cause是自身`。

但 Throwable 的 getCause() 方法是这样写的：
```java
    public Throwable getCause() {
        return (cause == this ? null : cause);
    }
```
也就是说这里不太可能导致死循环才对。

这个时候另外一个同事看了下这个业务自定义的Exception的代码，结果发现这个代码里覆盖了getCause()方法，是这样写的：
```java
    public Throwable getCause() {
        return cause;
    }
```
看到这就懂了，难怪上面那段代码会陷入死循环中…

到此可以说找到了解决方法，但`问题在于怎么会出现cause是本身的现象`，通常我们在写代码的时候不可能这么做，
`根据内存里的exception stack，一路翻业务的代码，发现不可能出现抛出这个自定义异常cause为自身的现象`。

还好继续一路跟踪，有同事发现`在某中间件的代码中会对异常做一个处理，如果发现异常里的root cause是其他的异常，则会将cause设置为本身`
（这是`RPC框架`，主要是`为了避免服务端抛的异常客户端没有相应的包，从而导致反序列化失败`）。

看到这里就知道`为什么cause会被设置为本身`了，于是写了段简单的`代码测试下，看看是不是会出现死循环`，
结果发现`如果是用Java序列化，不会…而用hessian老版本的序列化/反序列化，则会…`

继续跟踪代码，发现`原因在于hessian老版本做序列化/反序列化，如果出现子类和父类都有一个相同的field，那么其实这两个field都会被序列化，再反序列化的时候按照顺序父类的field值就成了这个instance的值`，
而`之前RPC框架覆盖的是Throwable的cause field，并不是业务自定义异常里的cause field`（这是因为`当时认为业务自定义异常里不可能会有cause field`）…

于是`整个问题的出现基本能解释通了`，`为什么只有一个机房有问题呢，发现原来是因为刚好那个机房有这个应用依赖的另外一个应用在做beta发布`…

上面这个故障尽管是一系列因素造成的，但`究其根本仍然是自定义异常错误覆盖getCause()方法造成的`，实在是一个莫大的杯具，
幸运的是还好这个故障暴露出来了，否则完全就是`一颗不定时炸弹`…

---
近期在测试机器还碰到一个`应用启动后过几分钟就crash的现象`，dmesg里显示不是`系统kill`的，从`core dump`来看竟然是`在SocketOutputStream.socketWrite()的时候crash`了，
于是`用BTrace在启动时跟踪`了下，`发现是类似native stack爆掉的原因，业务方检查后发现是一个配置有问题，导致产生了很深的堆栈`…

---
近来碰到的问题好像特别多，还碰到`几个机器响应时间不太一致的现象`，硬件等完全相同，但响应时间能差上个几倍，查这种问题真心麻烦，
超级幻想`JVM能支持动态地打开一个开关，显示某个方法走过的所有路径的耗时(Greys)`…

---
之前做的那次订阅我的账号里阿里和非阿里占比的调查，有人感兴趣结果，那我说下吧，总共接到62个人反馈
（话说这是我一天接到过的最多的消息…），尽管占总订阅人数的比重不高，但我也只能按这个来看吧，
其中阿里人有12个，非阿里人50个，这是我比较期望的，呵呵。



原文：[一行代码引发的杯具 - 毕玄-林昊](http://hellojava.info/?p=180)
